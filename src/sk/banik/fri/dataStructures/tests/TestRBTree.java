package sk.banik.fri.dataStructures.tests;

import static org.junit.Assert.*;

import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.junit.Test;

import sk.banik.fri.dataStructures.AbstractNode;
import sk.banik.fri.dataStructures.BasicMapCollection;
import sk.banik.fri.dataStructures.RBTree;
import sk.banik.fri.dataStructures.RBTree.RBNode;
import sk.banik.fri.dataStructures.RBTreeOld;

public class TestRBTree {

	@Test
	public void test() {
		String[] args = new String[]{"S"
				, "E"
				, "A"
				, "R"
				, "C"
				, "H"
				, "E"
				, "X"
				, "A"
				, "M"
				, "P"
				, "L"
				, "E"};
        RBTree<String, Integer> tree = new RBTree<String, Integer>();
        for (int i = 0; i < args.length; i++) {
            String key = args[i];
            tree.insert(key, i);
        }
        tree.printBetter();
        boolean checkStatus = tree.check();
        System.out.println("is RB Tree? : " + checkStatus);
        assertTrue(checkStatus);
	}

	@Test
	public void testInsert() throws Exception {
//		BasicMapCollection<Integer, String> rbTree = new RBTree<Integer, String>();
		BasicMapCollection<Integer, String> rbTree = new RBTreeOld<Integer, String>();
		
		HashMap<Integer, String> backupStructure = new HashMap<Integer, String>();
		int maxTestedCount = 10*10;
		
		do {
			// insert pair <key, value>
			
			Double dKey = (Math.random() * maxTestedCount * maxTestedCount);
			while (backupStructure.containsKey(dKey.intValue())) {
				dKey = (Math.random() * maxTestedCount * maxTestedCount);
			}
			String val = "" + dKey.intValue();
			rbTree.insert(dKey.intValue(), val);
			backupStructure.put(dKey.intValue(), val);
			// check if tree contains inserted node
			String foundValue = rbTree.find(dKey.intValue());
			assertNotNull(foundValue);
			assertTrue(foundValue.equals(val));
			// check the consistency - if children is bigger and less and if parent is
			Method findNodeMethod = rbTree.getClass().getDeclaredMethod(
					"findNode", Comparable.class);
			findNodeMethod.setAccessible(true);
			Object returnedValue = findNodeMethod.invoke(rbTree,
					dKey.intValue());
			AbstractNode foundNode = (AbstractNode) returnedValue;
			if (foundNode.leftChild != null)
				assertTrue(foundNode.key.compareTo(foundNode.leftChild.key) > 0);
			if (foundNode.rightChild != null)
				assertTrue(foundNode.key.compareTo(foundNode.rightChild.key) < 0);
			// check if size is good
			assertEquals(rbTree.size(), backupStructure.size());
			// general check
			assertTrue(rbTree.check());
			
			// do this many times for random values
			// and remember generated values
		} while (backupStructure.size() < maxTestedCount);
	}
	
	@Test
	public void testBstDelete() throws Exception {
//		BasicMapCollection<Integer, String> rbTree = new RBTree<Integer, String>();
		BasicMapCollection<Integer, String> rbTree = new RBTreeOld<Integer, String>();
		HashMap<Integer, String> backupStructure = new HashMap<Integer, String>();
		int maxTestedCount = 1000;
		
		List<Integer> in = new LinkedList<Integer>();
		in.addAll(Arrays.asList(153602,927757,284673,868362,663554,73736,155657,993283,206867,602136,909337,446480,964633,507929,682004,958511,127011,477218,530478,141348,192553,985122,303147,163899,108604,450619,323642,30782,28734,704565,221249,127045,450627,864326,141390,233551,333897,948319,108626,127063,202836,751698,516188,950354,329818,905325,415844,485475,116837,698479,14439,989287,807008,526437,358507,176241,350321,866426,395391,630899,49276,833648,401531,94339,929933,688271,219275,86154,481418,895133,559259,202903,649361,491678,518301,356505,974994,14493,352408,501914,964755,340120,907408,200867,858281,411811,575663,712864,94383,94385,235696,567473,958644,250040,997555,235711,522425,20673,778434,659648,995524,571588,592068,407752,16590,696517,800988,336084,26833,794846,270551,624861,24789,540880,461021,927982,57569,385249,680173,186603,913661,239858,895231,192753,305394,762099,35068,305401,532746,983308,885000,786699,39177,170251,265,375049,542980,944387,102668,260365,57616,909597,852255,825630,983325,583964,14614,678163,997653,174361,542995,162078,129308,776469,164128,870702,432418,825635,905506,796988,698682,946493,12599,162106,115000,653616,211258,966964,928078,729417,915790,16707,991564,485699,397635,92487,352589,981318,321869,475469,684353,385353,811330,557402,53587,614746,452946,162135,500048,829807,350561,811364,489838,495981,373102,932194,385393,936312,374,395647,670067,145785,854384,317817,371067,399747,610700,45448,96648,825759,102810,967057,18848,330150,244134,22949,272801,936358,784802,668064,795046,401836,90538,63915,106929,831932,160178,932286,283063,444848,575934,356798,238013,543158,475576,952753,635336,59841,362948,577994,842190,80325,827851,412108,741825,897474,537031,344533,344534,90578,750047,238038,260566,403921,338397,270812,301533,555476,616919,907757,102883,80359,739820,795104,672250,96757,457200,303613,672240,436730,952816,502264,686603,25090,377345,477699,190982,399875,342531,788996,340493,582146,371215,346635,248337,645661,94745,2584,240159,262681,930350,461350,176672,422436,725550,354861,621088,414252,635427,115245,487979,971327,633400,733754,414261,823865,768562,766514,438844,422460,797233,342584,225854,819761,313915,541256,313920,555596,25160,801349,983617,301643,492104,535128,883292,807512,301661,801365,41563,524884,692820,98914,203364,367215,332398,356983,131701,174709,86649,698992,88698,836209,449166,750215,938654,500371,146074,651920,154265,377509,98977,113315,504483,950955,430767,899748,889508,559778,619172,99001,158395,723633,305855,772784,920242,78527,43710,27330,846538,877259,80585,115401,346828,60107,139983,680665,275153,39638,916181,295646,490204,29404,398052,750319,893670,508652,379630,752359,320233,912098,86766,946913,715519,582399,563954,678641,887536,897779,369414,791304,90888,746241,692992,281358,928516,297743,498444,768795,776986,369428,318229,267031,166683,103197,733975,185118,873235,830227,113441,336676,58145,852782,353057,328482,408366,398125,273192,150317,379700,203569,627519,918329,338748,926512,74559,924495,944972,13124,439107,699201,648002,291657,719707,150359,408415,975703,846679,658263,830289,910163,78689,691051,449383,125795,19299,316263,945001,127850,596857,938879,189299,723833,283516,469887,822129,580488,394119,557965,873352,854920,531332,324489,428936,27535,336788,897948,39827,13203,148369,39829,891803,375699,949141,197538,103337,648096,945061,244655,996256,410537,635833,412594,228278,269235,25528,357309,560049,168888,58299,883638,697265,820147,840627,123838,504768,752579,502735,730055,365524,234450,980,394206,218074,7129,971731,166877,498648,375781,781290,400355,785390,791529,830441,613347,639971,269290,803837,461811,254967,48117,91124,922617,582640,685040,209912,37884,791537,787442,916467,603127,99328,699404,723975,386056,5136,685082,709656,517141,967709,338961,76820,728094,269340,381982,631828,619561,171044,119847,240683,785440,109613,326697,242737,984123,699443,54329,824374,721974,23614,916531,386125,353356,648259,568386,25675,752710,678980,513111,216145,126045,537706,777321,619627,91235,638059,812129,722021,648294,949370,214135,951414,844916,859253,775283,787568,373882,912524,334982,513156,984203,78983,949378,787608,611484,212117,337043,259221,103574,701586,670865,685201,980117,640150,236707,961711,140448,423076,359587,951465,464046,193707,124076,156849,134325,353468,242877,840882,998607,494789,812231,390345,17614,230608,881878,603348,439515,990443,9444,433390,976103,324841,660711,924897,259312,130293,515314,769268,144637,38145,554252,742670,423188,759069,232728,189721,607509,945425,621846,814355,714027,654636,716076,881956,83240,167212,32048,922941,685375,167228,226621,628023,189766,212292,791877,458056,871768,245087,251230,99681,605545,626029,189810,374132,966011,353648,290163,419199,173435,128379,988532,576886,353668,615823,638350,318858,836995,146834,656792,101778,427411,521630,7580,370073,388504,79260,17822,902547,564630,384410,77214,44448,329124,19877,681388,294307,318892,533925,619961,464311,884157,882111,214454,540094,599487,134581,841147,464319,13759,699848,269762,101830,961991,773568,665025,138703,832990,81363,363987,298461,484827,968145,808429,245218,736745,658924,17895,400865,912869,777698,632290,703975,773627,161267,85495,415228,509436,538099,800247,11777,892428,499203,480770,136714,56842,933381,331273,93711,376330,638491,476691,38424,609810,58908,562710,833071,194081,706094,24101,744995,910887,302638,671270,521771,247347,630331,73271,81462,271932,974391,83519,845377,572998,437846,36432,386647,321111,958041,613982,187994,265821,480862,69208,728656,58972,925264,226915,652904,448100,499300,378465,87655,638575,724589,786029,290403,822886,312943,839264,990816,351863,675449,308848,87669,56948,620156,882298,827003,808565,779890,597618,527988,310906,42623,59008,439941,829064,30340,970370,235150,126604,261777,528019,11931,548499,833169,450200,990893,679593,636589,812705,294571,110259,151223,491185,339634,407235,812746,882373,863942,691905,128719,255696,118487,458462,708307,632535,954064,689877,640749,368355,839403,890602,114411,71403,831207,437995,259827,775930,853756,982780,937724,407285,628479,311027,761587,239353,757514,454412,227087,362248,562968,192273,163606,366355,192283,126749,323352,960275,687895,165663,194332,880429,96035,433952,339746,522016,79657,902949,577314,536358,552762,872248,30519,22327,827188,622384,177977,841520,636745,311110,966472,493377,958274,757573,704346,1873,225110,317266,434012,784209,83802,206680,649042,198495,720726,227169,894830,429923,534381,32614,558959,237417,30576,194416,659326,726908,65402,880503,417661,806775,53118,606071,454532,548746,618380,804747,184197,49035,753541,274324,944026,513937,184212,790420,595856,96161,253859,307109,890789,589731,698276,38832,753599,657340,489406,692144,853943,190401,20427,57297,868319,399317,622557,210900,802779,720874,188385,231398,471023,190443,14314,974821,784359,247794,22516,462833,120825,598005,999409,333818));
		
		do {
			// insert pair <key, value>
			Double dKey = (Math.random() * maxTestedCount * maxTestedCount);
			while (backupStructure.containsKey(dKey.intValue())) {
				dKey = (Math.random() * maxTestedCount * maxTestedCount);
			}
			dKey = new Double(in.remove(0));
			
			String val = "" + dKey.intValue();
			rbTree.insert(dKey.intValue(), val);
			backupStructure.put(dKey.intValue(), val);
		} while (backupStructure.size() < maxTestedCount);
		
		// ------ DEBUG ----------
		List<Object> list = Arrays.asList(backupStructure.keySet().toArray());
//		printList(list);
		
		LinkedList<Integer> inserted = new LinkedList<Integer>();
		inserted.addAll(backupStructure.keySet());
		
		for (int i = 0; i < backupStructure.size(); i++) {
			// be sure that nodes will be deleted randomized
			int index = (int) (Math.random() * inserted.size());
			int key = (int) inserted.remove(index);
			
//				if (key == 663554)
//					System.out.println(key);
			
			// try to remove node with key
			String deletedValue= rbTree.delete(key);
			String expectedValue = backupStructure.remove(key);
//			assertEquals(expectedValue, deletedValue);
			
			// check if tree contains inserted node
			String foundValue = rbTree.find(key);
			assertNull(foundValue);
			
			// check if size is good
			assertEquals(rbTree.size(), backupStructure.size());
			// general check
				 assertTrue(rbTree.check());
			
			// do this that much how much values are in backup structure
		}
	}
	
	private void printList(List<Object> list) {
		if (list == null)
			return;
		for (int i = 0; i < list.size(); i++) {
			System.out.print(list.get(i).toString() + " ");
		}
		System.out.println();
	}
	
	@Test
	public void testDeleteIntensive() throws Exception {
		for (int i = 0; i < 10 * 1000; i++) {
			testBstDelete();
			if ((i % 10) == 0)
				System.out.println(i);
		}
	}
}
